<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WLAN Share</title>
    <link rel="stylesheet" href="/static/styles.css">
</head>
<body>
    <div class="container">
        <header>
            <h1> WLAN Share</h1>
            <p>Dateien einfach über das lokale Netzwerk teilen</p>
        </header>

        <section class="upload-section">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon"></div>
                <h3>Dateien hochladen</h3>
                <p>Dateien hier hinziehen oder klicken zum Auswählen</p>
                <input type="file" id="fileInput" multiple style="display: none;">
                <button class="select-files-btn" onclick="document.getElementById('fileInput').click()">
                    Dateien auswählen
                </button>
            </div>
            
            <div class="progress-container" id="progressContainer" style="display: none;">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">0%</div>
            </div>
            
            <div class="selected-files" id="selectedFiles" style="display: none;">
                <h4>Ausgewählte Dateien:</h4>
                <div class="file-list" id="fileList"></div>
                <button class="upload-btn" onclick="uploadFiles()"> Hochladen</button>
            </div>
        </section>

        <section class="sync-text-section">
            <h3>📋 Sync-Text</h3>
            <div class="sync-text-container">
                <button class="expand-btn" id="expandBtn" onclick="toggleExpand()" title="Expand/Collapse">
                    <svg id="expandIcon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                        <polyline points="7 13 12 18 17 13"></polyline>
                        <polyline points="7 6 12 11 17 6"></polyline>
                    </svg>
                </button>
                <div class="text-input-wrapper">
                    <textarea 
                        id="syncText" 
                        class="sync-text-field" 
                        placeholder="Text hier eingeben zum Synchronisieren..."
                        rows="1"
                    ></textarea>
                    <div class="text-field-actions">
                        <span class="status-indicator" id="statusIndicator"></span>
                        <button class="send-btn" id="sendBtn" onclick="sendFromButton()" title="Send">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                                <line x1="22" y1="2" x2="11" y2="13"></line>
                                <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                            </svg>
                        </button>
                    </div>
                </div>
                <button class="copy-btn" id="copyBtn" onclick="copyLastText()" title="Copy to clipboard">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                    </svg>
                </button>
            </div>
        </section>

        <section class="file-list-section">
            <div class="section-header">
                <h2> Verfügbare Dateien ({{ files|length }})</h2>
                {% if files %}
                <a href="/zip" class="zip-download-btn"> Alles als ZIP</a>
                {% endif %}
            </div>

            {% if files %}
            <div class="files-grid">
                {% for file in files %}
                <div class="file-card">
                    <div class="file-info">
                        <div class="file-icon"></div>
                        <div class="file-details">
                            <div class="file-name">{{ file.name }}</div>
                            <div class="file-size">{{ file.size_mb }} MB</div>
                        </div>
                    </div>
                    <div class="file-actions">
                        <a href="/download/{{ file.name }}" class="download-btn"> Download</a>
                        <button class="delete-btn" onclick="deleteFile('{{ file.name }}')"></button>
                    </div>
                </div>
                {% endfor %}
            </div>
            {% else %}
            <div class="empty-state">
                <div class="empty-icon"></div>
                <h3>Keine Dateien vorhanden</h3>
                <p>Dateien hochladen um zu beginnen</p>
            </div>
            {% endif %}
        </section>
    </div>

    <script>
        let selectedFiles = [];
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const selectedFilesDiv = document.getElementById('selectedFiles');
        const fileList = document.getElementById('fileList');
        const progressContainer = document.getElementById('progressContainer');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            selectedFiles = Array.from(e.dataTransfer.files);
            displaySelectedFiles();
        });

        fileInput.addEventListener('change', (e) => {
            selectedFiles = Array.from(e.target.files);
            displaySelectedFiles();
        });

        function displaySelectedFiles() {
            if (selectedFiles.length === 0) return;
            selectedFilesDiv.style.display = 'block';
            fileList.innerHTML = '';
            selectedFiles.forEach(file => {
                const div = document.createElement('div');
                div.textContent = file.name;
                fileList.appendChild(div);
            });
        }

        async function uploadFiles() {
            if (selectedFiles.length === 0) return;
            progressContainer.style.display = 'block';
            
            for (let i = 0; i < selectedFiles.length; i++) {
                const formData = new FormData();
                formData.append('file', selectedFiles[i]);
                
                try {
                    await fetch('/upload', { method: 'POST', body: formData });
                    const progress = Math.round(((i + 1) / selectedFiles.length) * 100);
                    progressFill.style.width = progress + '%';
                    progressText.textContent = progress + '%';
                } catch (error) {
                    console.error('Upload error:', error);
                }
            }
            
            setTimeout(() => location.reload(), 1000);
        }

        async function deleteFile(filename) {
            if (!confirm('Datei löschen?')) return;
            try {
                await fetch(`/delete/${encodeURIComponent(filename)}`, { method: 'DELETE' });
                location.reload();
            } catch (error) {
                console.error('Delete error:', error);
            }
        }

        // Sync text functionality
        const syncText = document.getElementById('syncText');
        const statusIndicator = document.getElementById('statusIndicator');
        const expandBtn = document.getElementById('expandBtn');
        let lastSentText = '';
        let lastSentTimestamp = 0;
        let isExpanded = false;
        let manuallyExpanded = false;
        let lastKnownContent = '';
        let lastKnownTimestamp = 0;

        // Auto-adjust height
        function adjustHeight() {
            if (!manuallyExpanded) {
                const singleLineHeight = 45;
                syncText.style.height = 'auto';
                
                if (syncText.value.length > 0) {
                    const scrollHeight = syncText.scrollHeight;
                    if (scrollHeight > singleLineHeight && !isExpanded) {
                        syncText.style.height = Math.min(scrollHeight, 150) + 'px';
                    } else if (isExpanded) {
                        syncText.style.height = Math.min(scrollHeight, 150) + 'px';
                    } else {
                        syncText.style.height = singleLineHeight + 'px';
                    }
                } else {
                    syncText.style.height = singleLineHeight + 'px';
                }
            }
        }

        // Update status indicator
        function updateStatus(status) {
            if (status === 'sent') {
                statusIndicator.innerHTML = '✓';
                statusIndicator.style.color = '#667eea';
                statusIndicator.style.textShadow = '0 1px 2px rgba(0,0,0,0.1)';
            } else if (status === 'delivered') {
                statusIndicator.innerHTML = '✓✓';
                statusIndicator.style.color = '#48bb78';
                statusIndicator.style.textShadow = '0 1px 2px rgba(0,0,0,0.1)';
            } else {
                statusIndicator.innerHTML = '';
                statusIndicator.style.textShadow = '';
            }
        }

        // Handle input
        syncText.addEventListener('input', () => {
            adjustHeight();
        });

        // Handle focus
        syncText.addEventListener('focus', () => {
            if (!manuallyExpanded && syncText.value.length > 50) {
                isExpanded = true;
                adjustHeight();
            }
        });

        // Handle Enter key
        syncText.addEventListener('keydown', async (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                await sendSyncText();
                // Always collapse to single line after sending
                isExpanded = false;
                manuallyExpanded = false;
                syncText.rows = 1;
                syncText.style.height = '45px';
                syncText.classList.remove('expanded');
                expandBtn.classList.remove('expanded');
            }
        });

        // Send sync text to server
        async function sendSyncText() {
            const text = syncText.value.trim();
            if (text === '') return;
            
            lastSentText = text;
            lastSentTimestamp = Date.now();
            updateStatus('sent');
            
            try {
                const timestamp = lastSentTimestamp;
                const payload = JSON.stringify({
                    text: text,
                    timestamp: timestamp
                });
                const blob = new Blob([payload], { type: 'application/json' });
                const formData = new FormData();
                formData.append('file', blob, '.clipboard-sync.txt');
                
                await fetch('/upload', { method: 'POST', body: formData });
                
                // Wait a bit then check for delivery
                setTimeout(checkDeliveryStatus, 1500);
            } catch (error) {
                console.error('Sync error:', error);
                updateStatus('');
            }
        }

        // Check if message was delivered
        function checkDeliveryStatus() {
            if (lastKnownTimestamp >= lastSentTimestamp) {
                updateStatus('delivered');
            }
        }

        // Toggle expand
        function toggleExpand() {
            manuallyExpanded = !manuallyExpanded;
            if (manuallyExpanded) {
                syncText.rows = 5;
                syncText.style.height = '150px';
                syncText.classList.add('expanded');
                expandBtn.classList.add('expanded');
            } else {
                // Always collapse to single line
                syncText.rows = 1;
                syncText.style.height = '45px';
                syncText.classList.remove('expanded');
                expandBtn.classList.remove('expanded');
                isExpanded = false;
            }
        }
        
        // Send from button
        async function sendFromButton() {
            await sendSyncText();
            // Collapse after sending
            if (manuallyExpanded) {
                toggleExpand();
            } else {
                isExpanded = false;
                syncText.rows = 1;
                syncText.style.height = '45px';
                syncText.classList.remove('expanded');
            }
        }

        // Copy last text (with fallback for non-HTTPS)
        function copyLastText() {
            const textToCopy = syncText.value.trim() || lastSentText;
            if (!textToCopy) return;
            
            let success = false;
            
            // Method 1: Modern Clipboard API (works on HTTPS and localhost)
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(textToCopy)
                    .then(() => {
                        showCopySuccess();
                    })
                    .catch((error) => {
                        console.log('Clipboard API failed, trying fallback method:', error);
                        fallbackCopy(textToCopy);
                    });
            } else {
                // Method 2: Fallback for non-secure contexts
                fallbackCopy(textToCopy);
            }
        }
        
        // Fallback copy method using textarea
        function fallbackCopy(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.left = '-999999px';
            textarea.style.top = '-999999px';
            document.body.appendChild(textarea);
            
            textarea.focus();
            textarea.select();
            
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showCopySuccess();
                } else {
                    showCopyError();
                }
            } catch (error) {
                console.error('Fallback copy failed:', error);
                showCopyError();
            } finally {
                document.body.removeChild(textarea);
            }
        }
        
        // Show copy success animation
        function showCopySuccess() {
            const btn = document.getElementById('copyBtn');
            btn.classList.add('success');
            
            const originalHTML = btn.innerHTML;
            btn.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="20 6 9 17 4 12"></polyline></svg>';
            
            setTimeout(() => {
                btn.innerHTML = originalHTML;
                btn.classList.remove('success');
            }, 1500);
        }
        
        // Show copy error
        function showCopyError() {
            const btn = document.getElementById('copyBtn');
            const originalHTML = btn.innerHTML;
            btn.style.background = 'linear-gradient(135deg, #f56565 0%, #e53e3e 100%)';
            btn.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M18 6L6 18M6 6l12 12"></path></svg>';
            
            setTimeout(() => {
                btn.innerHTML = originalHTML;
                btn.style.background = '';
            }, 1500);
        }

        // Poll for sync text updates
        async function pollSyncText() {
            try {
                const response = await fetch('/download/.clipboard-sync.txt');
                if (response.ok) {
                    const jsonText = await response.text();
                    try {
                        const data = JSON.parse(jsonText);
                        const text = data.text || jsonText;
                        const timestamp = data.timestamp || Date.now();
                        
                        if (text !== lastKnownContent) {
                            lastKnownContent = text;
                            lastKnownTimestamp = timestamp;
                            
                            // Always update the text field, even if focused (for clipboard sync)
                            syncText.value = text;
                            lastSentText = text;
                            adjustHeight();
                            
                            // Check if this is our own message for delivery status
                            if (lastSentTimestamp > 0 && timestamp === lastSentTimestamp) {
                                updateStatus('delivered');
                            } else if (timestamp !== lastSentTimestamp) {
                                // Message from another device (or clipboard)
                                updateStatus('');
                            }
                        } else if (lastKnownTimestamp >= lastSentTimestamp && lastSentTimestamp > 0) {
                            // Content is same but we sent a message - mark as delivered
                            updateStatus('delivered');
                        }
                    } catch (e) {
                        // Fallback for plain text format
                        if (jsonText !== lastKnownContent) {
                            lastKnownContent = jsonText;
                            lastKnownTimestamp = Date.now();
                            
                            // Always update for clipboard sync
                            syncText.value = jsonText;
                            lastSentText = jsonText;
                            adjustHeight();
                        }
                    }
                }
            } catch (error) {
                // File might not exist yet, ignore
            }
        }

        // Start polling
        setInterval(pollSyncText, 1000);
        pollSyncText(); // Initial load
    </script>
</body>
</html>
